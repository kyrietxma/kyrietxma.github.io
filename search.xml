<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Linux服务器搭建Java开发环境之安装jdk]]></title>
    <url>%2Fkyrietxma.github.io%2F2019%2F04%2F05%2FLinux%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%90%AD%E5%BB%BAJava%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E4%B9%8B%E5%AE%89%E8%A3%85jdk%2F</url>
    <content type="text"><![CDATA[实习感受： 在公司实习期间一直是在windows上面进行java开发，然后打成war包部署在linux服务器上面，linux服务器上面的正式环境和测试环境都是别人搭建好的，svn服务器也是别人搭建好的，抱着一种学习的心态的就去买了个阿里云服务器于是开始搭建java开发环境，今天先记录下载服务器安装jdk的操作 1 首先查看我们linxu服务器的操作系统：执行命令：cat /proc/version 12root@iZuf61idmzh5imkso8okwdZ:/# cat proc/versionLinux version 4.4.0-142-generic (buildd@lgw01-amd64-033) (gcc version 5.4.0 20160609 (Ubuntu 5.4.0-6ubuntu1~16.04.10) ) #168-Ubuntu SMP Wed Jan 16 21:00:45 UTC 2019 查出当前服务器是64位系统，去下载相对版本的jdk 2 进入Oracle官网，下载JDKOracle官网 3 安装jdk ①利用命令在usr目录下创建Java和jdk文件夹，具体命令如下： 1234cd usr 进入usr目录，mkdir java 创建Java文件夹，cd java 进入Java文件夹mkdir jdk 创建jdk文件夹 ②把下载后的jdk压缩包（本地下载），通过xftp上传到服务器的usr/java/jdk目录下 ③ 解压jdk压缩包 1tar -zxvf jdk-8u202-linux-x64.tar.gz 解压缩之后，我们看到在该目录下会生成一个jdk1.8.0_202 目录，如图 ④ 然后我们开始配置环境变量使用命令 vim /etc/profile 打开环境变量配置文件，将如下内容添加到该文件的末尾 12345#set java environment export JAVA_HOME=/usr/java/jdk/jdk1.8.0_202 export JRE_HOME=$&#123;JAVA_HOME&#125;/jre export CLASSPATH=.:$JAVA_HOME/lib:$JRE_HOME/lib:$CLASSPATH export PATH=$JAVA_HOME/bin:$JRE_HOME/bin:$JAVA_HOME:$PATH 这里的/usr/java/jdk/jdk1.8.0_202代表服务器中jdk的安装目录（如果你的目录路径和我上面的不一致，需要修改为自己设置路径），⑤修改完成后，使用wq!命令进行保存即可⑥然后执行命令 source /etc/profile 使环境变量更新。 4 检查jdk是否安装成功，java -version 1234root@iZuf61idmzh5imkso8okwdZ:~# java -versionjava version &quot;1.8.0_202&quot;Java(TM) SE Runtime Environment (build 1.8.0_202-b08)Java HotSpot(TM) 64-Bit Server VM (build 25.202-b08, mixed mode) jdk安装成功，大功告成！！]]></content>
      <tags>
        <tag>linux服务器</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SpringBoot整合Swagger2，构建Api文档]]></title>
    <url>%2Fkyrietxma.github.io%2F2019%2F04%2F01%2FSpringboot%E6%95%B4%E5%90%88Swagger2%EF%BC%8C%E6%9E%84%E5%BB%BAApi%E6%96%87%E6%A1%A3%2F</url>
    <content type="text"><![CDATA[手写Api文档的几个痛点： 1 文档需要更新的时候，需要再次发送一份给前端，也就是文档更新交流不及时。2 接口返回结果不明确3 不能直接在线测试接口，通常需要使用工具，比如postman4 接口文档太多，不好管理 Swagger也就是为了解决这个问题，当然也不能说Swagger就一定是完美的，当然也有缺点，最明显的就是代码移入性比较强。 其他的不多说，想要了解Swagger的，可以去Swagger官网，可以直接使用Swagger editor编写接口文档，当然我们这里讲解的是SpringBoot整合Swagger2，直接生成接口文档的方式。一 依赖 123456789101112&lt;dependency&gt; &lt;groupId&gt;io.springfox&lt;/groupId&gt; &lt;artifactId&gt;springfox-swagger2&lt;/artifactId&gt; &lt;version&gt;2.7.0&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;io.springfox&lt;/groupId&gt; &lt;artifactId&gt;springfox-swagger-ui&lt;/artifactId&gt; &lt;version&gt;2.7.0&lt;/version&gt; &lt;/dependency&gt; 二 Swagger2配置类 1234567891011121314151617181920212223242526272829303132333435363738394041424344package com.kyrie.mybatis.config;import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.Configuration;import springfox.documentation.builders.ApiInfoBuilder;import springfox.documentation.builders.PathSelectors;import springfox.documentation.builders.RequestHandlerSelectors;import springfox.documentation.service.ApiInfo;import springfox.documentation.spi.DocumentationType;import springfox.documentation.spring.web.plugins.Docket;import springfox.documentation.swagger2.annotations.EnableSwagger2;/** * @Author: txma * @Date: 2019/3/31 21:50 * @Version: 1.0 */@Configuration@EnableSwagger2public class SwaggerConfig &#123; @Bean public Docket CreateRestApi()&#123; return new Docket(DocumentationType.SWAGGER_2) .apiInfo(apiInfo()) .select() .apis(RequestHandlerSelectors.basePackage(&quot;com.kyrie.mybatis.controller&quot;)) .paths(PathSelectors.any()) .build(); &#125; private ApiInfo apiInfo() &#123; return new ApiInfoBuilder() .title(&quot;Spring Boot中使用Swagger2构建RESTful API&quot;) .description(&quot;restFul api 文档构建利器&quot;) .termsOfServiceUrl(&quot;https://blog.csdn.net/m0_43584016&quot;) .contact(&quot;txma&quot;) .version(&quot;1.0&quot;) .build(); &#125;&#125; 三 Restful 接口 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859package com.kyrie.mybatis.controller;import com.kyrie.mybatis.entity.Student;import io.swagger.annotations.Api;import io.swagger.annotations.ApiImplicitParam;import io.swagger.annotations.ApiOperation;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.RequestMethod;import org.springframework.web.bind.annotation.RestController;import java.util.ArrayList;import java.util.List;/** * @Author: txma * @Date: 2019/3/31 22:06 * @Version: 1.0 */@RestController@RequestMapping(value = &quot;/student&quot;)@Api(description = &quot;学生管理&quot;)public class StudentController &#123; private int flag; ArrayList&lt;Student&gt; students = new ArrayList&lt;&gt;(); @ApiOperation(value = &quot;获取学生列表&quot;, notes = &quot;获取所有学生信息&quot;) @RequestMapping(value = &quot;/get&quot;, method = RequestMethod.GET) public List&lt;Student&gt; hello() &#123; students.add(new Student(&quot;逻辑&quot;, &quot;123456&quot;)); students.add(new Student(&quot;叶文杰&quot;, &quot;123456&quot;)); for(Student attribute : students) &#123; System.out.println(attribute); &#125; return students; &#125; @ApiOperation(value = &quot;新增学生&quot;,notes = &quot;新增学生信息&quot;) @RequestMapping(value = &quot;/add&quot;,method = RequestMethod.POST) public int addStudent(Student student)&#123; return flag; &#125; @ApiOperation(value = &quot;获取学生详细信息&quot;,notes =&quot;根据用户输入的id来查询学生的详细信息&quot;) @ApiImplicitParam(name = &quot;id&quot;,value = &quot;学生id&quot;,required = true) @RequestMapping(value = &quot;user/&#123;id&#125;&quot;,method = RequestMethod.GET) public Student getStudent(int id)&#123; Student student = new Student(1,&quot;kyrie&quot;,&quot;111111&quot;); return student; &#125; @ApiOperation(value = &quot;删除学生信息&quot;,notes = &quot;根据id删除学生信息&quot;) @ApiImplicitParam(name = &quot;id&quot;,value = &quot;学生id&quot;,required = true) @RequestMapping(value = &quot;user&#123;/id&#125;&quot;,method = RequestMethod.DELETE) public int delStudent(int id)&#123; return 1; &#125; &#125; 四 项目结构五 运行项目，访问https://locallhost:8080/swagger-ui.html,效果如下： Description 描述参数名称，在controller中为参数添加描述，代码如下：至此，springboot整合swagger2来构建Api文档已经完成 六 swagger常用注解说明 swagger通过注解表明该接口会生成文档，包括接口名、请求方法、参数、返回信息的等等。 @Api：修饰整个类，描述Controller的作用@ApiOperation：描述一个类的一个方法，或者说一个接口@ApiParam：单个参数描述@ApiModel：用对象来接收参数@ApiProperty：用对象接收参数时，描述对象的一个字段@ApiResponse：HTTP响应其中1个描述@ApiResponses：HTTP响应整体描述@ApiIgnore：使用该注解忽略这个API@ApiError ：发生错误返回的信息@ApiImplicitParam：一个请求参数@ApiImplicitParams：多个请求参数]]></content>
      <tags>
        <tag>SpringBoot    Swagger2</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[如何利用IDEA上传项目到Github]]></title>
    <url>%2Fkyrietxma.github.io%2F2019%2F03%2F29%2FLinux%2050%E6%9D%A1%E5%B8%B8%E7%94%A8%E7%9A%84%E5%91%BD%E4%BB%A4%2F</url>
    <content type="text"><![CDATA[1.ls -a 列出当前目录下的所有文件，包括以.头的隐含文件（如～/.bashrc） ls –l 列出当前目录下文件的详细信息 pwd 查看当前所在目录的绝对路经 cd 目录之间的移动 mkdir目录名 创建一个目录 rm 文件名 删除一个文件 cat文件名 查看文件内容（全屏查看） 7.more文件名 查看文件内容（可左右移动） less文件名查看文件内容（可上下左右移动） 9.mv 路径 文件名 把文件移动到路径下 mv文件名 文件名改名 grep字符文件名根据字符匹配来查看文件部分内容 find 路经 -name “字符串” 查找路经所在范围内满足字符串匹配的文件和目录 12.ln 源文件 链接名 创建源文件的硬链接 ln -s源文件 链接名创建源文件的软链接 13.touch 文件名 建立文件 14.df 显示文件系统的总容量，使用量，剩余量 15.du -b /home 查看目前/HOME目录的容量(k)及子目录的容量(k) fdisk -l 查看系统分区信息 mount -t 文件系统类型 设备路经 访问路经 18.chmod *** 文件名 改文件的写读执行权限 19.diff 文件名 文件名 比较文件 20.top 动态 ps –aux 静态 pstree 进程树查看系统进程 程序名 &amp; 后台运行程序 fg 把后台运行的进程调回前台 bg 把前台运行进程调到后台 halt init 0 shutdown –h now 关闭系统 reboot init 6 重启系统 init [0123456] 改变系统运行级,7种 at at 5pm + 3 days /bin/ls 指定三天后下午5:00执行/bin/ls crontab 周期性任务命令（建议详细学习） 27.date 显示日期的命令 28.cal 显示日历的命令 29.bc 不错的简单计算器 30.man 命令 查询命令帮助 31.which 查看可执行档案的位置 32.whereis 查看档案的位置 33.locate 配合数据库查看档案位置 34.gzip bzip2 compress 压缩，解压命令 35.vi 文件名 用VI编辑文件 36.alias 命令别名设置指令 unalias 释放别名 37.tar 打包 解包指令 38.head 显示文件的头几行 tail 显示文件的后几行 39.| 管道 &gt; 重定向 40.od 以二进制形式读取档案的内容 41.su 登入超级管理员 sudo 以管理者身份执行命令 42.tar包安装指令 ./configure –prefix=/usr/local 编译前的配置 make 编译 make install 安装编译好的源码包 43.rpm –参数 rpm的安装 查询 删除 升级等 44.ifconfig 网络配置命令 ping ping目标主机 netstat 显示监听端口及进程 45.clear 清屏 46.useradd 加用户 47.passwd 修改密码 48.chgrp chown 修改文件的用户组所有者 49.dd 用来备份的指令 dd if=”input-file” of=”output-file” 50.sh 脚本文件 执行脚本文件]]></content>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[IntelliJ IDEA下载安装配置教程（自用配置）]]></title>
    <url>%2Fkyrietxma.github.io%2F2019%2F03%2F29%2FIntelliJ%20IDEA%E4%B8%8B%E8%BD%BD%E5%AE%89%E8%A3%85%E9%85%8D%E7%BD%AE%E6%95%99%E7%A8%8B%EF%BC%88%E8%87%AA%E7%94%A8%E9%85%8D%E7%BD%AE%EF%BC%89%2F</url>
    <content type="text"><![CDATA[1 下载 IDEA IDEA官网2 安装IDEA 3 配置IDEA(重点) ① 配置默认jdk版本② 设置按钮的具体设置③ 设置默认字体和字体大小④设置注解颜色⑤设置文件默认编码格式 4 关闭IDEA自动更新 在File-&gt;Settings-&gt;Appearance &amp; Behavior-&gt;System Settings-&gt;Updates下取消Automatically check updates for勾选 5 隐藏.idea文件夹和.iml等文件IntelliJ IDEA项目会自动生成一个.idea文件夹和.iml文讲，看着实在是碍眼，所以对以上文件进行隐藏处理在File-&gt;Settings-&gt;Editor-&gt;File Types下的”Ignore files and folders”一栏添加 .idea;.iml;等配置如下图所示6 类和方法注释模板 ①修改类注释模板 在File-&gt;Settings-&gt;Editor-&gt;File and Code Templates下分别修改Class，Interface，Enum等注释模板，Class模板部分修改如下，其余的举一反三进行修改。以下所示的${DESCRIPTION}是自定义变量，会在创建类时请求输入 ②修改方法注释模板 在File-&gt;Settings-&gt;Editor-&gt;Live Templates下添加自定义Template Group，并在自定义Template Group下添加自定义Template，具体配置如下图所示 说明：在完成如上配置后，只需在方法内执行/**+Enter键即可生成注释，切记这里说的是方法内部，因为methodParameters()的作用域只在方法内部 7 代码格式化代码格式化的快捷键为Ctrl+Alt+L，如果在类中执行代码格式化则会对代码进行排版，若焦点在类或者文件夹上，则会弹出格式化选项提示框，弹出框如下图所示:Include subdirectories:是否对子目录也进行格式化Optimize imports:优化导入的类和包Rearrange enries:对代码顺序进行调整(将Filed放在Method前边) Filters即配置过滤条件，表示对哪些文件进行格式化 8 自动导入包在Intellij IDEA一次只能导入单个包，没有像Eclipse快速导入包的快捷键Ctrl+Shift+O，但是Intellij IDEA下有个自动导入包的功能。在File-&gt;Settings-&gt;Editor-&gt;General-&gt;Auto Import下进行配置，具体配置如下如所示: 9 Maven配置在File-&gt;Settings-&gt;Build,Execution,Deployment-&gt;Build Tools-&gt;Maven下对Maven进行配置，个人配置如下图所*注意：Import Maven projects automatically:表示IntelliJ IDEA会实时监控项目的pom.xml文件进行项目变动设置，建议进行勾选10 复用eclipse的快捷键 11编辑器每次打开新项目的时候 12实用插件推荐 快捷键提示插件Key promoter是在你通过非快捷键方式使用某功能时 为你提供快捷键建议 在开始记不住快捷键的情况下 强烈推荐安装 翻译插件翻译插件 TranslationPlugin,支持支持中英互译、单词朗读,详细安装文档请参考:TranslationPlugin介绍与安装手册 热部署插件JRebelJRebel热部署插件安装和使用请参考:JRebel热部署插件安装和使用 Maven HelperMaven 辅助插件 用于查找Maven依赖冲突非常好用的一款插件 安装步骤请参考:Maven Helper安装使用 Properties to YAML Converter在开发SpringBoot项目时，会需要把Properties的配置格式改为 YAML格式，Properties to YAML Converter提供了很好的支持 阿里巴巴代码规范插件p3c-pmd详细安装和使用请参考:阿里巴巴代码规范插件p3c-pmd 开发必备快捷键IntelliJ IDEA提供了丰富的快捷键组合来加快开发效率，但是快捷键太多琳琅满目也会给人无从下手的感觉。下面是我个人整理的在开发过程中必备的快捷键，(注:IDEA快捷键可能会与其他软件快捷键产生冲突，在开发过程中有必要进行取舍)此外IntelliJ IDEA 官方提供了学习IDEA快捷键的一个插件:IDE Features Trainer:https://plugins.jetbrains.com/plugin/8554?pr=idea，大家可以自行去插件库下载学习 Ctrl相关快捷键 介绍Ctrl + B 进入光标所在的方法/变量的接口或是定义处，等效于Ctrl + 左键单击Ctrl + D 复制光标所在行或复制选择内容，并把复制内容插入光标位置下面Ctrl + F 在当前文件进行文本查找Ctrl + H 查看类的继承结构Ctrl + N 通过类名定位文件Ctrl + O 快速重写父类方法Ctrl + P 方法参数提示Ctrl + Y 删除光标所在行或删除选中的行Ctrl + W 递进式选择代码块Ctrl + Z 撤销Ctrl + 1,2,3…9 定位到对应数值的书签位置 结合Ctrl + Shift + 1,2,3…9使用Ctrl + F1 在光标所在的错误代码出显示错误信息Ctrl + F12 弹出当前文件结构层，可以在弹出的层上直接输入进行筛选Ctrl + Space 基础代码补全默认在Windows系统上被输入法占用，需要进行修改，建议修改为Ctrl + 逗号Ctrl + / 注释光标所在行代码，会根据当前不同文件类型使用不同的注释符号 Alt相关快捷键 介绍Alt + Q 弹出一个提示，显示当前类的声明/上下文信息Alt + Enter 根据光标所在问题，提供快速修复选择 Shift相关快捷键 介绍Shift + F3 在查找模式下，定位到上一个匹配处Ctrl+Alt相关快捷键 介绍Ctrl + Alt + B 在某个调用的方法名上使用会跳到具体的实现处Ctrl + Alt + L 格式化代码 可以对当前文件和整个包目录使用Ctrl + Alt + M 快速抽取方法Ctrl + Alt + O 优化导入的类和包 可以对当前文件和整个包目录使用Ctrl + Alt + T 对选中的代码弹出环绕选项弹出层Ctrl + Alt + V 快速引进变量Ctrl + Alt + F7 寻找类或是变量被调用的地方，以弹出框的方式显示Ctrl + Alt + 左方向键 退回到上一个操作的地方Ctrl + Alt + 右方向键 前进到上一个操作的地方 Ctrl+Shift相关快捷键 介绍Ctrl + Shift + F 根据输入内容查找整个项目或指定目录内文件Ctrl + Shift + H 查看方法的继承结构Ctrl + Shift + J 自动将下一行合并到当前行末尾Ctrl + Shift + N 通过文件名定位打开文件/目录，打开目录需要在输入的内容后面多加一个正斜杠Ctrl + Shift + R 根据输入内容替换对应内容，范围为整个项目或指定目录内文件Ctrl + Shift + U 对选中的代码进行大/小写轮流转换Ctrl + Shift + W 递进式取消选择代码块Ctrl + Shift + Z 取消撤销Ctrl + Shift + / 代码块注释Ctrl + Shift + + 展开所有代码Ctrl + Shift + - 折叠所有代码Ctrl + Shift + 1,2,3…9 快速添加指定数值的书签Ctrl + Shift + F7 高亮显示所有该选中文本，按Esc高亮消失Ctrl + Shift + Space 智能代码提示Ctrl + Shift + Enter 自动结束代码，行末自动添加分号 其他快捷键 介绍F2 跳转到下一个高亮错误或警告位置F3 在查找模式下，定位到下一个匹配处F4 编辑源]]></content>
      <tags>
        <tag>IDEA</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HTML文件怎么引入高德地图]]></title>
    <url>%2Fkyrietxma.github.io%2F2019%2F03%2F29%2FHTML%E6%96%87%E4%BB%B6%E6%80%8E%E4%B9%88%E5%BC%95%E5%85%A5%E9%AB%98%E5%BE%B7%E5%9C%B0%E5%9B%BE%2F</url>
    <content type="text"><![CDATA[1.首先，注册高德地图开发者，这个直接在官网上注册，输入必要信息就行，如下：2.注册完成后，进入个人中心，依次点击“应用管理”-&gt;“我的应用”-&gt;“创建新应用”，如下，这里输入应用名称，选择类型就行： 3 接着就需要为应用添加key值，点击右上角的+号，就会弹出添加窗口，这里我们选择“Web端（JS API）”，如下：4 添加key值成功后，就会在应用列表中看到刚才添加的key值，如下，后面的代码中需要用到这个key值：5.最后就是编写代码，在html页面中引入3D地图了，如下，代码很简单，主要是创建div容器，然后通过JS引入地图到这个容器中，这里需要JS API版本在1.4.0以上，指定地图模式为3D，key值替换成自己应用的key值： 12345678910111213141516171819202122232425262728293031323334&lt;!doctype html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;initial-scale=1.0, user-scalable=no, width=device-width&quot;&gt; &lt;link rel=&quot;stylesheet&quot; href=&quot;https://a.amap.com/jsapi_demos/static/demo-center/css/demo-center.css&quot; /&gt; &lt;style&gt; html, body, #container &#123; width: 100%; height: 100%; &#125; &lt;/style&gt; &lt;title&gt;地图加载完成&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;div id=&quot;container&quot;&gt;&lt;/div&gt;&lt;script src=&quot;https://webapi.amap.com/maps?v=1.4.13&amp;key=你的key值&quot;&gt;&lt;/script&gt;&lt;script src=&quot;https://a.amap.com/jsapi_demos/static/demo-center/js/demoutils.js&quot;&gt;&lt;/script&gt;&lt;script&gt; var map = map = new AMap.Map(&apos;container&apos;, &#123; resizeEnable: true, viewMode:&apos;3D&apos; &#125;); map.on(&quot;complete&quot;, function()&#123; log.success(&quot;地图加载完成！&quot;); &#125;);&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 6 浏览效果如图：]]></content>
      <tags>
        <tag>JS 高德地图</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[如何利用IDEA上传项目到Github]]></title>
    <url>%2Fkyrietxma.github.io%2F2019%2F03%2F29%2FIDEA%E4%B8%8A%E4%BC%A0%E9%A1%B9%E7%9B%AE%E5%88%B0Github%2F</url>
    <content type="text"><![CDATA[第一种情况： 新的项目第一次推送到Github步骤：① 选择 share project on Github② 添加仓库名，添加描述③ 选择你要放到GitHub上的文件（大部分是选择你修改过的文件，但是本次我是第一次发布项目，所以全选）④ 显示上传成功⑤ 登录个人GitHub账号，查看项目 第二种情况：GitHub中已经有了项目，在IDEA中修改了项目中的代码，更新GitHub中的代码 ① 修改代码： 对于修改了的代码，IDEA会自动显示为不同颜色，比如新建的文件，文件名显示红色；修改了已有文件中的代码，被修改部分显示绿色② 修改完代码后，重新上传代码： 在项目上传的过程中，我们遵从添加到本地仓库–&gt;提交和推到远程仓库的步骤 A 添加到本地仓库： 右键项目名，选择Git,点击Add:添加项目到本地仓库，具体步骤如下图： 成功添加到本地仓库： B 提交并推送代码到远程仓库： 右键项目名，选择Git，点击Commit directory 具体操作如下： ③ 在个人GitHub中查看项目的更新情况 代码更新成功！！至此，关于使用IDEA上传代码的操作已经完成。]]></content>
      <tags>
        <tag>GitHub  IDEA</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用navicat为数据表添加外键]]></title>
    <url>%2Fkyrietxma.github.io%2F2019%2F03%2F29%2F%E4%BD%BF%E7%94%A8navicat%E4%B8%BA%E6%95%B0%E6%8D%AE%E8%A1%A8%E6%B7%BB%E5%8A%A0%E5%A4%96%E9%94%AE%2F</url>
    <content type="text"><![CDATA[1 选择需要操作的表，打开设计表。点击外键2 名（自动生成，无需添加） 字段（选择需要添加外键的字段） 参考模式（选择表所在的数据库） 参考表（关联表名） 参考字段（关联表的关联字段） 删除时（当删除关联表时，set null该字段置空） 更新时（当关联表更新时，该字段级联更新）3 外键设置完成]]></content>
      <tags>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[批量查询全过程]]></title>
    <url>%2Fkyrietxma.github.io%2F2019%2F03%2F29%2F%E6%89%B9%E9%87%8F%E6%9F%A5%E8%AF%A2%E7%9A%84%E5%85%A8%E8%BF%87%E7%A8%8B%EF%BC%88%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%89%2F</url>
    <content type="text"><![CDATA[具体步骤如下：1 controller层（查询开始的接口） ① 调用UserService查询用户列表 ② 调用RoleService查询当前用户所拥有的角色list123456789101112131415@RequestMapping(&quot;listUser&quot;) public String list(Model model) &#123; //查询用户 List&lt;User&gt; user = userService.list(); model.addAttribute(&quot;user&quot;, user); //用户角色对应map Map&lt;User, List&lt;Role&gt;&gt; user_roles = new HashMap&lt;&gt;(); for (User user : user) &#123; //获得当前用户所拥有的角色list List&lt;Role&gt; roles = roleService.listRoles(user); user_roles.put(user, roles); &#125; model.addAttribute(&quot;user_roles&quot;, user_roles); return &quot;listUser&quot;; &#125; 2 调用UserService查询用户，返回一个用户list，具体实现在它的实现层中，代码如下：① 调用UserMapper层从数据库进行查询123456789@Override public List&lt;User&gt; list() &#123; //相当于用户的一个工具类，设置查询结果list的排序规则 UserExample example = new UserExample(); //当前查询到的用户按降序排序 example.setOrderByClause(&quot;id desc&quot;); return userMapper.selectByExample(example); &#125; 3 UserMapper层的方法如下：返回一个用户list 1List&lt;User&gt; selectByExample(UserExample example); 4 UserMapper.xml具体如下： 123456789101112131415&lt;select id=&quot;selectByExample&quot; parameterType=&quot;com.how2java.pojo.UserExample&quot; resultMap=&quot;BaseResultMap&quot;&gt; select &lt;if test=&quot;distinct&quot;&gt; distinct &lt;/if&gt; &apos;false&apos; as QUERYID, &lt;include refid=&quot;Base_Column_List&quot; /&gt; from user &lt;if test=&quot;_parameter != null&quot;&gt; &lt;include refid=&quot;Example_Where_Clause&quot; /&gt; &lt;/if&gt; &lt;if test=&quot;orderByClause != null&quot;&gt; order by $&#123;orderByClause&#125; &lt;/if&gt; &lt;/select&gt;]]></content>
      <tags>
        <tag>批量查询</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用Navicat premium 12画ER图的几种操作方法]]></title>
    <url>%2Fkyrietxma.github.io%2F2019%2F03%2F29%2F%E4%BD%BF%E7%94%A8Navicat%20premium%2012%E7%94%BBER%E5%9B%BE%E7%9A%84%E5%87%A0%E7%A7%8D%E6%93%8D%E4%BD%9C%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[最近接触的关系数据库类型比较多，所以用上了 Navicat Premium。这个工具真的很强大，可以连接大多数关系数据库。再也不用来回切换数据库连接工具了。同时这个工具可以直接直观的查看几个表的ER图，即关联关系，便于设计模型。言归正传介绍方法。实验工具为 Navicat ，具体操作如下： 第一种： 1 模型–&gt; 新建模型2 选择相应的数据库名称和数据库版本，点击确定 如下：3 点击工具–&gt;从数据库导入，选择你需要建立关系的数据表，点击开始4 生成ER图，如下： 第二种：1 选择目标数据库名或者具体的某一张数据表，右键单击，选择逆向表到模型（选择的是userinfo表） 2 点击工具–&gt;从数据库导入，选择你需要建立关系的数据表，点击开始3 生成ER图，如下：]]></content>
      <tags>
        <tag>ER图 数据库</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[shiro学习记录]]></title>
    <url>%2Fkyrietxma.github.io%2F2019%2F01%2F16%2Fshiro%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95%EF%BC%88%E4%BA%8C%EF%BC%89%2F</url>
    <content type="text"><![CDATA[1 登录的用户对象，封装成一个token对象2 根据SecurityUtils获得一个subject对象，再调用subject的login(token)方法进行登录，如果正常登陆（执行subject.login(token)成功，就能在全局通过SecurityUtils.getSubject().getPrincipal()获取用户信息。3 MD5加密： 12String password=&quot;123&quot;;String MD5password = new Md5Hash(password).toString(); 4 对原有密码添加盐值 1234//加盐值（随机数）String salt = new SecureRandomNumberGenerator().nextBytes().toString();//加盐值后的密码newPassword = new SimpleHash(algorithmName, password, salt).toString(); SSM集成shiro 1 web.xml做以下几件事件事：① 指定spring的配置文件有两个，分别是用于链接数据库的applicationContext.xml和用于配置shiro的applicationContext-shiro.xml② 指定springmvc的配置文件：springMVC.xml③ 使用shiro过滤器 1&lt;filter-class&gt;org.springframework.web.filter.Delegating&lt;/filter-class&gt; 具体代码如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;web-app xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns=&quot;http://java.sun.com/xml/ns/javaee&quot; xmlns:web=&quot;http://java.sun.com/xml/ns/javaee&quot; xsi:schemaLocation=&quot;http://java.sun.com/xml/ns/javaee http://java.sun.com/xml/ns/javaee/web-app_2_5.xsd&quot; version=&quot;2.5&quot;&gt; &lt;!-- spring的配置文件--&gt; &lt;context-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt; classpath:applicationContext.xml, classpath:applicationContext-shiro.xml &lt;/param-value&gt; &lt;/context-param&gt; &lt;listener&gt; &lt;listener-class&gt;org.springframework.web.context.ContextLoaderListener&lt;/listener-class&gt; &lt;/listener&gt; &lt;!-- spring mvc核心：分发servlet --&gt; &lt;servlet&gt; &lt;servlet-name&gt;mvc-dispatcher&lt;/servlet-name&gt; &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt; &lt;!-- spring mvc的配置文件 --&gt; &lt;init-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;classpath:springMVC.xml&lt;/param-value&gt; &lt;/init-param&gt; &lt;load-on-startup&gt;1&lt;/load-on-startup&gt; &lt;/servlet&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;mvc-dispatcher&lt;/servlet-name&gt; &lt;url-pattern&gt;/&lt;/url-pattern&gt; &lt;/servlet-mapping&gt; &lt;!-- Shiro配置 --&gt; &lt;filter&gt; &lt;filter-name&gt;shiroFilter&lt;/filter-name&gt; &lt;filter-class&gt;org.springframework.web.filter.DelegatingFilterProxy&lt;/filter-class&gt; &lt;init-param&gt; &lt;param-name&gt;targetFilterLifecycle&lt;/param-name&gt; &lt;param-value&gt;true&lt;/param-value&gt; &lt;/init-param&gt; &lt;/filter&gt; &lt;filter-mapping&gt; &lt;filter-name&gt;shiroFilter&lt;/filter-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt; &lt;/filter-mapping&gt; &lt;/web-app&gt; 2 applicationContext.xml 配置数据库和mybatis的扫描mapper 12345678910111213141516171819202122232425262728&lt;context:annotation-config /&gt; &lt;context:component-scan base-package=&quot;com.how2java.service&quot; /&gt; &lt;bean id=&quot;dataSource&quot; class=&quot;org.springframework.jdbc.datasource.DriverManagerDataSource&quot;&gt; &lt;property name=&quot;driverClassName&quot;&gt; &lt;value&gt;com.mysql.jdbc.Driver&lt;/value&gt; &lt;/property&gt; &lt;property name=&quot;url&quot;&gt; &lt;value&gt;jdbc:mysql://localhost:3306/shiro?characterEncoding=UTF-8&lt;/value&gt; &lt;/property&gt; &lt;property name=&quot;username&quot;&gt; &lt;value&gt;root&lt;/value&gt; &lt;/property&gt; &lt;property name=&quot;password&quot;&gt; &lt;value&gt;admin&lt;/value&gt; &lt;/property&gt; &lt;/bean&gt; &lt;bean id=&quot;sqlSession&quot; class=&quot;org.mybatis.spring.SqlSessionFactoryBean&quot;&gt; &lt;property name=&quot;typeAliasesPackage&quot; value=&quot;com.how2java.pojo&quot; /&gt; &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot;/&gt; &lt;property name=&quot;mapperLocations&quot; value=&quot;classpath:com/how2java/mapper/*.xml&quot;/&gt; &lt;/bean&gt; &lt;bean class=&quot;org.mybatis.spring.mapper.MapperScannerConfigurer&quot;&gt; &lt;property name=&quot;basePackage&quot; value=&quot;com.how2java.mapper&quot;/&gt; &lt;/bean&gt; 3 applicationContext-shiro.xml 提供shiro的相关配置 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384&lt;!-- 配置shiro的过滤器工厂类，id- shiroFilter要和我们在web.xml中配置的过滤器一致 --&gt; &lt;bean id=&quot;shiroFilter&quot; class=&quot;org.apache.shiro.spring.web.ShiroFilterFactoryBean&quot;&gt; &lt;!-- 调用我们配置的权限管理器 --&gt; &lt;property name=&quot;securityManager&quot; ref=&quot;securityManager&quot; /&gt; &lt;!-- 配置我们的登录请求地址 --&gt; &lt;property name=&quot;loginUrl&quot; value=&quot;/login&quot; /&gt; &lt;!-- 如果您请求的资源不再您的权限范围，则跳转到/403请求地址 --&gt; &lt;property name=&quot;unauthorizedUrl&quot; value=&quot;/unauthorized&quot; /&gt; &lt;!-- 退出 --&gt; &lt;property name=&quot;filters&quot;&gt; &lt;util:map&gt; &lt;entry key=&quot;logout&quot; value-ref=&quot;logoutFilter&quot; /&gt; &lt;/util:map&gt; &lt;/property&gt; &lt;!-- 权限配置 --&gt; &lt;property name=&quot;filterChainDefinitions&quot;&gt; &lt;value&gt; &lt;!-- anon表示此地址不需要任何权限即可访问 --&gt; /login=anon /index=anon /static/**=anon /doLogout=logout &lt;!--所有的请求(除去配置的静态资源请求或请求地址为anon的请求)都要通过登录验证,如果未登录则跳到/login --&gt; /** = authc &lt;/value&gt; &lt;/property&gt; &lt;/bean&gt; &lt;!-- 退出过滤器 --&gt; &lt;bean id=&quot;logoutFilter&quot; class=&quot;org.apache.shiro.web.filter.authc.LogoutFilter&quot;&gt; &lt;property name=&quot;redirectUrl&quot; value=&quot;/index&quot; /&gt; &lt;/bean&gt; &lt;!-- 会话ID生成器 --&gt; &lt;bean id=&quot;sessionIdGenerator&quot; class=&quot;org.apache.shiro.session.mgt.eis.JavaUuidSessionIdGenerator&quot; /&gt; &lt;!-- 会话Cookie模板 关闭浏览器立即失效 --&gt; &lt;bean id=&quot;sessionIdCookie&quot; class=&quot;org.apache.shiro.web.servlet.SimpleCookie&quot;&gt; &lt;constructor-arg value=&quot;sid&quot; /&gt; &lt;property name=&quot;httpOnly&quot; value=&quot;true&quot; /&gt; &lt;property name=&quot;maxAge&quot; value=&quot;-1&quot; /&gt; &lt;/bean&gt; &lt;!-- 会话DAO --&gt; &lt;bean id=&quot;sessionDAO&quot; class=&quot;org.apache.shiro.session.mgt.eis.EnterpriseCacheSessionDAO&quot;&gt; &lt;property name=&quot;sessionIdGenerator&quot; ref=&quot;sessionIdGenerator&quot; /&gt; &lt;/bean&gt; &lt;!-- 会话验证调度器，每30分钟执行一次验证 ，设定会话超时及保存 --&gt; &lt;bean name=&quot;sessionValidationScheduler&quot; class=&quot;org.apache.shiro.session.mgt.ExecutorServiceSessionValidationScheduler&quot;&gt; &lt;property name=&quot;interval&quot; value=&quot;1800000&quot; /&gt; &lt;property name=&quot;sessionManager&quot; ref=&quot;sessionManager&quot; /&gt; &lt;/bean&gt; &lt;!-- 会话管理器 --&gt; &lt;bean id=&quot;sessionManager&quot; class=&quot;org.apache.shiro.web.session.mgt.DefaultWebSessionManager&quot;&gt; &lt;!-- 全局会话超时时间（单位毫秒），默认30分钟 --&gt; &lt;property name=&quot;globalSessionTimeout&quot; value=&quot;1800000&quot; /&gt; &lt;property name=&quot;deleteInvalidSessions&quot; value=&quot;true&quot; /&gt; &lt;property name=&quot;sessionValidationSchedulerEnabled&quot; value=&quot;true&quot; /&gt; &lt;property name=&quot;sessionValidationScheduler&quot; ref=&quot;sessionValidationScheduler&quot; /&gt; &lt;property name=&quot;sessionDAO&quot; ref=&quot;sessionDAO&quot; /&gt; &lt;property name=&quot;sessionIdCookieEnabled&quot; value=&quot;true&quot; /&gt; &lt;property name=&quot;sessionIdCookie&quot; ref=&quot;sessionIdCookie&quot; /&gt; &lt;/bean&gt; &lt;!-- 安全管理器 --&gt; &lt;bean id=&quot;securityManager&quot; class=&quot;org.apache.shiro.web.mgt.DefaultWebSecurityManager&quot;&gt; &lt;property name=&quot;realm&quot; ref=&quot;databaseRealm&quot; /&gt; &lt;property name=&quot;sessionManager&quot; ref=&quot;sessionManager&quot; /&gt; &lt;/bean&gt; &lt;!-- 相当于调用SecurityUtils.setSecurityManager(securityManager) --&gt; &lt;bean class=&quot;org.springframework.beans.factory.config.MethodInvokingFactoryBean&quot;&gt; &lt;property name=&quot;staticMethod&quot; value=&quot;org.apache.shiro.SecurityUtils.setSecurityManager&quot; /&gt; &lt;property name=&quot;arguments&quot; ref=&quot;securityManager&quot; /&gt; &lt;/bean&gt; &lt;bean id=&quot;databaseRealm&quot; class=&quot;com.how2java.realm.DatabaseRealm&quot;&gt; &lt;/bean&gt; &lt;!-- 保证实现了Shiro内部lifecycle函数的bean执行 --&gt; &lt;bean id=&quot;lifecycleBeanPostProcessor&quot; class=&quot;org.apache.shiro.spring.LifecycleBeanPostProcessor&quot; /&gt;&lt;/beans&gt; 4 springMVC.xml基本配置、增加了对shiro的支持、指定了异常处理类 12345678910&lt;!--启用shiro注解 --&gt; &lt;bean class=&quot;org.springframework.aop.framework.autoproxy.DefaultAdvisorAutoProxyCreator&quot; depends-on=&quot;lifecycleBeanPostProcessor&quot;&gt; &lt;property name=&quot;proxyTargetClass&quot; value=&quot;true&quot; /&gt; &lt;/bean&gt; &lt;bean class=&quot;org.apache.shiro.spring.security.interceptor.AuthorizationAttributeSourceAdvisor&quot;&gt; &lt;property name=&quot;securityManager&quot; ref=&quot;securityManager&quot; /&gt; &lt;/bean&gt; 5 log4j.properties 日配置文件 12345678# Global logging configurationlog4j.rootLogger=ERROR, stdout# MyBatis logging configuration...log4j.logger.com.how2java=TRACE# Console output...log4j.appender.stdout=org.apache.log4j.ConsoleAppenderlog4j.appender.stdout.layout=org.apache.log4j.PatternLayoutlog4j.appender.stdout.layout.ConversionPattern=%5p [%t] - %m%n 6 登录方法 123456789101112131415@RequestMapping(value=&quot;/login&quot;,method=RequestMethod.POST) public String login(Model model,String name, String password) &#123; Subject subject = SecurityUtils.getSubject(); UsernamePasswordToken token = new UsernamePasswordToken(name, password); try &#123; subject.login(token); Session session=subject.getSession(); session.setAttribute(&quot;subject&quot;, subject); return &quot;redirect:index&quot;; &#125; catch (AuthenticationException e) &#123; model.addAttribute(&quot;error&quot;, &quot;验证失败&quot;); return &quot;login&quot;; &#125; &#125;]]></content>
      <tags>
        <tag>个人学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[springboot项目使用mybatis逆向工程生成代码]]></title>
    <url>%2Fkyrietxma.github.io%2F2019%2F01%2F14%2Fspringboot%E9%A1%B9%E7%9B%AE%E4%BD%BF%E7%94%A8mybatis%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E7%94%9F%E6%88%90%E4%BB%A3%E7%A0%81%2F</url>
    <content type="text"><![CDATA[第一次写博客，权当是对自己学习的记录！！！ 开发工具 eclipse 数据库mysql 1 先简单说一下eclipse中如何使用mybatis的逆向工程来快速生成代码 利用eclipse搭建springboot项目的前提是eclipse安装了Spring插件，具体如下：help–&gt;eclipse marketplace 在也页面中输入Spring搜索后install当前插件并重启eclipse 2 在创建springboot项目的时候，选择 点击finish完成项目创建 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;2.1.1.RELEASE&lt;/version&gt; &lt;relativePath/&gt; &lt;!-- lookup parent from repository --&gt; &lt;/parent&gt; &lt;groupId&gt;com.kyrie&lt;/groupId&gt; &lt;artifactId&gt;mybatis-generator&lt;/artifactId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;name&gt;mybatis-generator&lt;/name&gt; &lt;description&gt;Demo project for Spring Boot&lt;/description&gt; &lt;properties&gt; &lt;java.version&gt;1.8&lt;/java.version&gt; &lt;/properties&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis.spring.boot&lt;/groupId&gt; &lt;artifactId&gt;mybatis-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;1.3.2&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;scope&gt;runtime&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;/plugin&gt; &lt;!-- mybatis-generator 插件 --&gt; &lt;plugin&gt; &lt;groupId&gt;org.mybatis.generator&lt;/groupId&gt; &lt;artifactId&gt;mybatis-generator-maven-plugin&lt;/artifactId&gt; &lt;version&gt;1.3.2&lt;/version&gt; &lt;configuration&gt; &lt;verbose&gt;true&lt;/verbose&gt; &lt;overwrite&gt;true&lt;/overwrite&gt; &lt;/configuration&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt;&lt;/project&gt; 在项目的pom.xml文件中引入mybatis的generator插件 3 下面配置两个重要的配置文件， ① 第一个是springboot项目的全局变量：application.yml 在配置application.yml文件的时候需要注意冒号后面的空格 123456789101112spring: datasource: driver-class-name: com.mysql.jdbc.Driver //mysql数据库驱动 url: jdbc:mysql://127.0.0.1:3306/newtest //数据库名 username: root password: rootserver: port: 8081#mybatis的配置mybatis: mapper-locations: classpath:mapper/*.xml type-aliases-package: com.kyrie.matx.entity ② 第二个重要的配置文件是generator的配置文件generatorConfig.xml 该配置文件中配置代码生成的具体策略，详细信息如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;!DOCTYPE generatorConfiguration PUBLIC &quot;-//mybatis.org//DTD MyBatis Generator Configuration 1.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-generator-config_1_0.dtd&quot;&gt;&lt;generatorConfiguration&gt; &lt;properties resource=&quot;application.yml&quot; /&gt; &lt;!-- mysql驱动的位置 这个是MySQL连接的jar包，你需要指定你自己计算机上的jar包的位置--&gt; &lt;classPathEntry location=&quot;C:/Users/tengxiao.ma/.m2/repository/mysql/mysql-connector-java/5.1.46/mysql-connector-java-5.1.46.jar&quot; /&gt; &lt;context id=&quot;Tables&quot; targetRuntime=&quot;MyBatis3&quot;&gt; &lt;commentGenerator&gt; &lt;!-- 是否生成注释代时间戳 --&gt; &lt;property name=&quot;suppressDate&quot; value=&quot;true&quot;/&gt; &lt;!-- 是否去除自动生成的注释 true：是 ： false:否 --&gt; &lt;property name=&quot;suppressAllComments&quot; value=&quot;true&quot;/&gt; &lt;/commentGenerator&gt; &lt;!-- JDBC连接 其中connectionURL后面的newtest改为你创建的数据库，紧跟在后面是数据库连接的账户和密码--&gt; &lt;jdbcConnection driverClass=&quot;com.mysql.jdbc.Driver&quot; connectionURL=&quot;jdbc:mysql://localhost:3306/newtest&quot; userId=&quot;root&quot; password=&quot;root&quot;&gt; &lt;/jdbcConnection&gt; &lt;!-- 非必需，类型处理器，在数据库类型和java类型之间的转换控制--&gt; &lt;!-- 默认false，把JDBC DECIMAL 和 NUMERIC 类型解析为 Integer，为 true时把JDBC DECIMAL 和 NUMERIC 类型解析为java.math.BigDecimal --&gt; &lt;javaTypeResolver&gt; &lt;!-- 是否使用bigDecimal， false可自动转化以下类型（Long, Integer, Short, etc.） --&gt; &lt;property name=&quot;forceBigDecimals&quot; value=&quot;false&quot; /&gt; &lt;/javaTypeResolver&gt; &lt;!-- 生成实体类地址 这里需要你改动，其中targetPackage需要根据你自己创建的目录进行改动 --&gt; &lt;javaModelGenerator targetPackage=&quot;com.kyrie.matx.entity&quot; targetProject=&quot;src/main/java&quot;&gt; &lt;!-- 从数据库返回的值被清理前后的空格 --&gt; &lt;property name=&quot;trimStrings&quot; value=&quot;true&quot; /&gt; &lt;!-- enableSubPackages:是否让schema作为包的后缀 --&gt; &lt;property name=&quot;enableSubPackages&quot; value=&quot;false&quot; /&gt; &lt;/javaModelGenerator&gt; &lt;!-- 生成mapper xml文件 这里不需要改动 --&gt; &lt;sqlMapGenerator targetPackage=&quot;mapper&quot; targetProject=&quot;src/main/resources&quot;&gt; &lt;!-- enableSubPackages:是否让schema作为包的后缀 --&gt; &lt;property name=&quot;enableSubPackages&quot; value=&quot;false&quot; /&gt; &lt;/sqlMapGenerator&gt; &lt;!-- 生成mapper xml对应Client 这里需要改动targetPackage，依据你自己的工程--&gt; &lt;javaClientGenerator targetPackage=&quot;com.kyrie.matx.dao&quot; targetProject=&quot;src/main/java&quot; type=&quot;XMLMAPPER&quot;&gt; &lt;!-- enableSubPackages:是否让schema作为包的后缀 --&gt; &lt;property name=&quot;enableSubPackages&quot; value=&quot;false&quot; /&gt; &lt;/javaClientGenerator&gt; &lt;!-- 配置表信息 --&gt; &lt;!-- schema即为数据库名 tableName为对应的数据库表 domainObjectName是要生成的实体类 enable*ByExample 是否生成 example类 个人觉得生成那么多的example类很繁琐，因此设置为false--&gt; &lt;table schema=&quot;newtest&quot; tableName=&quot;category&quot; domainObjectName=&quot;Category&quot; enableCountByExample=&quot;false&quot; enableDeleteByExample=&quot;false&quot; enableSelectByExample=&quot;false&quot; enableUpdateByExample=&quot;false&quot;&gt; &lt;/table&gt; &lt;table schema=&quot;newtest&quot; tableName=&quot;product&quot; domainObjectName=&quot;Product&quot; enableCountByExample=&quot;false&quot; enableDeleteByExample=&quot;false&quot; enableSelectByExample=&quot;false&quot; enableUpdateByExample=&quot;false&quot;&gt; &lt;/table&gt; &lt;/context&gt;&lt;/generatorConfiguration&gt; 4 运行generator，完成代码的自动生成 右击项目名：Run as–&gt;maven build,在Goals:mybatis-generator：generate 如下 apply–&gt;run 5 运行结果如下表示代码生成成功，但是在当前的页面是看不到的，需要删除项目（不要删除工作空间的项目），之后import这个maven项目6 完成这一系列工作之后，项目的具体结构如下：]]></content>
      <tags>
        <tag>个人笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[个人github练习]]></title>
    <url>%2Fkyrietxma.github.io%2F2019%2F01%2F09%2F%E4%B8%AA%E4%BA%BAgithub%E7%BB%83%E4%B9%A0%2F</url>
    <content type="text"></content>
      <tags>
        <tag>是不是跟github链接</tag>
      </tags>
  </entry>
</search>
